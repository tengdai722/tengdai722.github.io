<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode 1 Two Sum</title>
      <link href="/2019/09/20/LeetCode-1-Two-Sum/"/>
      <url>/2019/09/20/LeetCode-1-Two-Sum/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 206 Reverse Linked List</title>
      <link href="/2019/09/17/LeetCode-206-Reverse-Linked-List/"/>
      <url>/2019/09/17/LeetCode-206-Reverse-Linked-List/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 206 反转链表Java解答</p><a id="more"></a><blockquote><p>Reverse a singly linked list. </p><p>Example:<br>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p>Follow up:<br>A linked list can be reversed either iteratively or recursively. Could you implement both?</p></blockquote><p>反转链表，链表算法里必备技能点，基础的重中之重。很多有关链表反转、翻转的问题都是在这个基础上进行思维的延伸。既然要求用两个方法做，那就先说迭代再说递归。</p><p>解法一，迭代：</p><p>首先，肯定知道最后返回的结果是输入链表的链表尾节点。但先找到尾节点是很难继续实现的，因为链表没有办法高效获取前驱。往往这类问题很多时候都要想到建立一个新的节点，之后在遍历输入的时候重新组织节点顺序，将节点挂在新节点上。所以高效的做法是在遍历链表的过程中，一个一个的把输入链表的节点放到一个新的链表头部。所以思路就是建立一个新的链表头，每次遍历输入链表的节点都把他放到新链表的头部，这样遍历完成后就获得了反转的链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        ListNode reverseHead = <span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123; </span><br><span class="line">            ListNode second = first.next; </span><br><span class="line">            first.next = reverseHead; </span><br><span class="line">            reverseHead = first; </span><br><span class="line">            first = second; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverseHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二，递归：</p><p>每次想着用递归解法我习惯于用数学归纳法的思维去思考。先想输入规模最小的情况，再想比较general的情况。就本题来说，如果输入的是null或者单节点链表，必然是返回其本身。如果至少有两个节点，那么才开始递归。想一下，递归后的结果一定是一个规模更小问题的结果。即如果输入有k个节点，那么递归调用程序，输入原链表第二个节点所返回的结果，是一个反转后的，拥有k-1个节点的链表的首节点 —— 规模更小的问题的结果。那么如果把这个递归调用后返回的头节点所指向链表的尾节点的next域，指向被调用的节点的前驱，就相当反转了k个节点的链表。即利用k-1的结果去完成了k的问题。所以想到这里，在递归函数里要做的就是三件事：第一，记录即将被递归调用节点的前驱（或者换句话说，建立个新的节点指向输入的下一个节点，之后递归调用那个新节点）；第二，递归调用输入的下一个节点；第三，将返回结果的末尾指向记录好的前驱节点，完成反转。</p><p>这里需要注意的只有第三步，如何找到返回的结果链表的末尾。还是要回归到递归的本质，即返回的结果是一个已经反转完成的链表的首节点。反转完成的意思就是我们输入一个以节点S为头结点，节点E为尾结点的链表，那么调用后返回的节点是E，而S经过调用后变成了尾节点。即，递归调用时的输入本身，即是调用完成后我们需要的尾节点！所以我们并不需要每一次都去寻找递归调用后结果的尾节点，只需要直接利用递归调用的输入即可，因为这个输入就是调用完成的尾节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head; </span><br><span class="line">        ListNode second = head.next; </span><br><span class="line">        ListNode reverseHead = reverseList(second); </span><br><span class="line">        second.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> reverseHead; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始Python实现卷积神经网络识别手写数字(MNIST)</title>
      <link href="/2019/09/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BPython%E5%AE%9E%E7%8E%B0%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97-MNIST/"/>
      <url>/2019/09/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BPython%E5%AE%9E%E7%8E%B0%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97-MNIST/</url>
      
        <content type="html"><![CDATA[<p>从零开始用Python实现一个卷积神经网络(CNN)来识别手写数字(MNIST)。代码 + 推导同时奉上。</p><a id="more"></a><p>卷积神经网络(Convolution Neural Network)是时下很流行的一种神经网络。时至今日我们已有很多框架可以进行卷积神经网络的构建和训练，但是很多时候<br>只知其表不知其里。这边文章来推导一下卷积神经网络的相关公式，并用只用Python(numpy)来实现一个简单的卷积神经网络对MNIST数据集进行训练和预测。</p><h2 id="卷积神经网络的推导"><a href="#卷积神经网络的推导" class="headerlink" title="卷积神经网络的推导"></a>卷积神经网络的推导</h2><p>推导过程清楚了之后开始我们的实现吧！</p><h2 id="卷积神经网络的实现"><a href="#卷积神经网络的实现" class="headerlink" title="卷积神经网络的实现"></a>卷积神经网络的实现</h2><p>推导过程清楚了之后开始我们的实现吧！</p><p>我们需要一个SimpleCNN类，并初始化需要的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCNN</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_dim=<span class="number">28</span>, num_class=<span class="number">10</span>, filter_size=<span class="number">3</span>, channel=<span class="number">3</span>)</span>:</span></span><br><span class="line">        self.input_dim = input_dim  <span class="comment"># 输入的维度，MNIST默认是28</span></span><br><span class="line">        self.num_class = num_class  <span class="comment"># 需要判断的类的数目，MNIST任务是10个，0-9</span></span><br><span class="line">        self.filter_size = filter_size  <span class="comment"># 卷积核的维度，这里取长宽相等，默认为3</span></span><br><span class="line">        self.channel = channel  <span class="comment"># 卷积核的深度(通道数)，默认3</span></span><br><span class="line">        self.output_dim = input_dim - filter_size + <span class="number">1</span>  <span class="comment"># 计算输出的维度，公式：N_out = N_input - D_kernel + 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化参数，这里用了Xavier初始化</span></span><br><span class="line">        self.kernel = np.random.uniform(<span class="number">-1</span>, <span class="number">1</span>, (self.filter_size, self.filter_size, self.channel)) * \</span><br><span class="line">                      math.sqrt(<span class="number">6.</span> / (input_dim + self.output_dim))</span><br><span class="line">        self.params_w = np.random.uniform(<span class="number">-1</span>, <span class="number">1</span>, (self.num_class, self.output_dim, self.output_dim, self.channel)) * \</span><br><span class="line">                        math.sqrt(<span class="number">6.</span> / (self.input_dim + self.output_dim))</span><br><span class="line">        self.params_b = np.random.uniform(<span class="number">-1</span>, <span class="number">1</span>, self.num_class)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
