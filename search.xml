<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode 1099 Two Sum Less Than K</title>
      <link href="/2019/09/24/LeetCode-1099-Two-Sum-Less-Than-K/"/>
      <url>/2019/09/24/LeetCode-1099-Two-Sum-Less-Than-K/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 1099 Two Sum Less Than K | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC1099.png" width="75%" height="75%"><h2>解题思路</h2><p>又是two sum变体，更接近<a href="https://tengdai722.github.io/2019/09/23/LeetCode-167-Two-Sum-II-Input-array-is-sorted/" target="_blank" rel="noopener">LeetCode 167</a>。只要排序之后利用双指针即可。前后扫描，之后取最大的值，否则返回-1。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">twoSumLessThanK</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="keyword">int</span> pLeft = <span class="number">0</span>, pRight = A.length - <span class="number">1</span>, res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (pLeft &lt; pRight) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[pLeft] + A[pRight] &gt;= K) &#123;</span><br><span class="line">                pRight--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = Math.max(res, A[pLeft] + A[pRight]);</span><br><span class="line">                pLeft++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href="https://tengdai722.github.io/2019/09/20/LeetCode-1-Two-Sum/" target="_blank" rel="noopener">LeetCode 1 Two Sum</a><br><a href="https://tengdai722.github.io/2019/09/23/LeetCode-167-Two-Sum-II-Input-array-is-sorted/" target="_blank" rel="noopener">LeetCode 167 Two Sum II - Input array is sorted</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 653 Two Sum IV - Input is a BST</title>
      <link href="/2019/09/24/LeetCode-653-Two-Sum-IV-Input-is-a-BST/"/>
      <url>/2019/09/24/LeetCode-653-Two-Sum-IV-Input-is-a-BST/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 653 Two Sum IV - Input is a BST | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0653_1.png" width="75%" height="75%"><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0653_2.png" width="75%" height="75%"><h2>解题思路</h2><p>如果利用BST的性质，完全可以做中序遍历，直接得到有序的序列，之后进行双指针操作。也可以直接扫描所有的节点，之后利用set将结果存储起来，每次找到可以满足条件的节点就返回，否则存下当前节点并继续扫描。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(k - root.val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> findTarget(root.left, k) || findTarget(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href="https://tengdai722.github.io/2019/09/20/LeetCode-1-Two-Sum/" target="_blank" rel="noopener">LeetCode 1 Two Sum</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 560 Subarray Sum Equals K</title>
      <link href="/2019/09/24/LeetCode-560-Subarray-Sum-Equals-K/"/>
      <url>/2019/09/24/LeetCode-560-Subarray-Sum-Equals-K/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 560 Subarray Sum Equals K | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0560.png" width="75%" height="75%"><h2>解题思路</h2><p>又是加和等于特定目标的题。首先想一下暴力解法，可以$O(n^2)$实现，即每次固定子数组的首，之后依次判断每一个尾位置是否满足条件。这样的话，每次都要计算首尾之间的加和，多了很多重复的计算。那么如果我们提前计算出以每个位置为结尾，到数组起始位置元素和的话，也就是计算sum数组，那么sum数组任何两个位置元素的差值，就是子数组的和了。也就是说，我们有一个累计加和(sum)数组之后，就可以利用two sum的思想，在这个数组里找到做差为target的位置。又因为sum数组是可以实时更新的，所以我们并不需要开辟新的空间去存储，而是边算边存到map里面，这样一旦我们找到了满足条件的位置，就可以计入最后的结果。因为我们最后要统计个数，所以map里面存的key是从起点到数组每一个位置的元素的和，value是这个和出现的个数。这是因为不同的子数组完全可以产生同样的加和。初始化map需要把(0, 1)加入map，因为当什么都没有的时候，空子数组加和就是0。剩下的就和two sum一样，只是求和变成了求差。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum - k)) &#123;</span><br><span class="line">                res += map.get(sum - k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href="https://tengdai722.github.io/2019/09/20/LeetCode-1-Two-Sum/" target="_blank" rel="noopener">LeetCode 1 Two Sum</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 170 Two Sum III - Data structure design</title>
      <link href="/2019/09/23/LeetCode-170-Two-Sum-III-Data-structure-design/"/>
      <url>/2019/09/23/LeetCode-170-Two-Sum-III-Data-structure-design/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 170 Two Sum III - Data structure design | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0170.png" width="75%" height="75%"><h2>解题思路</h2><p>和基础Two Sum想法一样，只不过要注意重复的问题。比如map里只有一个0，那么当value是0的时候还是要返回false，因为只有一个数不满足条件，必须要两个数加和才可以。所以这样的话要记录同样数字的个数。如果加和等于目标的数对是同一个数字，要看map里面是不是有至少两个这样的数。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add the number to an internal data structure.. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        map.put(number, map.getOrDefault(number, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Find if there exists any pair of numbers which sum is equal to the value. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num1 : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> num2 = value - num1;</span><br><span class="line">            <span class="keyword">if</span> (num1 == num2 &amp;&amp; map.get(num1) &gt; <span class="number">1</span> || num1 != num2 &amp;&amp; map.containsKey(num2)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TwoSum object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TwoSum obj = new TwoSum();</span></span><br><span class="line"><span class="comment"> * obj.add(number);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.find(value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href="https://tengdai722.github.io/2019/09/20/LeetCode-1-Two-Sum/" target="_blank" rel="noopener">LeetCode 1 Two Sum</a><br><a href></a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Easy </tag>
            
            <tag> Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 167 Two Sum II - Input array is sorted</title>
      <link href="/2019/09/23/LeetCode-167-Two-Sum-II-Input-array-is-sorted/"/>
      <url>/2019/09/23/LeetCode-167-Two-Sum-II-Input-array-is-sorted/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 167 Two Sum II - Input array is sorted | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0167.png" width="75%" height="75%"><h2>解题思路</h2><p>排过序的数组直接用双指针扫描即可。也可以固定一个数，另一个数用二分查找，只是稍慢一点。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; numbers[i] != target - numbers[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &gt; target - numbers[j]) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = &#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href="https://tengdai722.github.io/2019/09/20/LeetCode-1-Two-Sum/" target="_blank" rel="noopener">LeetCode 1 Two Sum</a><br><a href></a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
            <tag> Binary Search </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1200 Minimum Absolute Difference</title>
      <link href="/2019/09/23/LeetCode-1200-Minimum-Absolute-Difference/"/>
      <url>/2019/09/23/LeetCode-1200-Minimum-Absolute-Difference/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 1200 Minimum Absolute Difference | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC1200_1.png" width="75%" height="75%"><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC1200_2.png" width="75%" height="75%"><h2>解题思路</h2><p>排序后第一遍扫描找到最小差值，第二遍扫描找到所有相差为最小差值的数对即可。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; minimumAbsDifference(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> minDiff = arr[<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minDiff &gt; arr[i] - arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                minDiff = arr[i] - arr[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] - arr[i - <span class="number">1</span>] == minDiff) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(arr[i - <span class="number">1</span>], arr[i])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href></a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1202 Smallest String With Swaps</title>
      <link href="/2019/09/22/LeetCode-1202-Smallest-String-With-Swaps/"/>
      <url>/2019/09/22/LeetCode-1202-Smallest-String-With-Swaps/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 1202 Smallest String With Swaps | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC1202_1.png" width="75%" height="75%"><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC1202_2.png" width="75%" height="75%"><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC1202_3.png" width="75%" height="75%"><h2>解题思路</h2><p>看到pair有的时候潜意识就会有种反射会想到图。具体怎么想到的呢？通过读题我们可以知道同一个位置可以和多个位置进行互换，那么通过足够多的互换，只要是连在一起的位置就都可以互相替换。也就是说互换的位置是可以传递的。既然如此，首先我们要知道哪些位置是互相连通的，也就是说，我们要找到所有“连在一起”的位置。想到这就更自然的往连通图和union find的方向思考了。</p><p>如果我们通过union find找到了所有连在一起的位置，那么接下来用贪心的思维直接去找每个位置字典序最小的字母就好。其实这里需要用数学归纳法证明一下如果n个位置可以连通互换，那么这n个位置的字母可以组成长度为n的全排列。也就是说，直接贪心是一定可以组成我们想要的字典序最小的排列的。最后对于每一个连通子图，把图里面的字母存到优先队列里就可以了，每次只拿最小的，那么当所有字母取完之后就是我们想要的最优答案。</p><p>这道题真的是非常好的一道题，逻辑思维，图，哈希表，和优先队列，全都考到了。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">smallestStringWithSwaps</span><span class="params">(String s, List&lt;List&lt;Integer&gt;&gt; pairs)</span> </span>&#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; pair : pairs) &#123;</span><br><span class="line">            union(pair.get(<span class="number">0</span>), pair.get(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        HashMap&lt;Integer, PriorityQueue&lt;Character&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> root = find(i);</span><br><span class="line">            id[i] = root;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(root)) &#123;</span><br><span class="line">                map.put(root, <span class="keyword">new</span> PriorityQueue&lt;Character&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(root).add(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            sb.append(map.get(id[i]).poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id[p] == p) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">int</span> q = find(id[p]);</span><br><span class="line">        id[p] = q;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pId = find(p);</span><br><span class="line">        <span class="keyword">int</span> qId = find(q);</span><br><span class="line">        <span class="keyword">if</span> (pId == qId) <span class="keyword">return</span>;</span><br><span class="line">        id[pId] = qId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href></a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Medium </tag>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1201 Ugly Number III</title>
      <link href="/2019/09/22/LeetCode-1201-Ugly-Number-III/"/>
      <url>/2019/09/22/LeetCode-1201-Ugly-Number-III/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 1201 Ugly Number III | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC1201_1.png" width="75%" height="75%"><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC1201_2.png" width="75%" height="75%"><h2>解题思路</h2><p>丑数2的升级版，又略有不同。之前的丑数都是找约数只是给定数字的数，而这次是只要能整除给定数字就可以，所以算是有一些区别。一开始用丑数2的思路一个个判断和找，果然超时了。既然是找个数，那能不能提前统计一下满足条件的数的个数呢，即给定一个数，小于等于这个数且能被给定3个数中任意一个数整除的数有多少呢？举例子，比如12，小于等于12，且能被2，3，4中任意一个整除的数有几个？这就用到了集合的<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%AE%B9%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">容斥原理</a>。即我们要求的满足条件数的个数，等于能被2整除的数 + 能被3整除的数 + 能被4整除的数 - 能被2，3同时整除的数 - 能被2，4同时整除的数 - 能被3，4同时整除的数 + 能被2，3，4同时整除的的数。如何求能同时被两个数整除的数呢？这里需要用到最小公倍数的概念，即想要求能被a和b同时整除的，且小于等于N的数的个数，做法是找到a和b的最小公倍数ab，之后N/ab就是所求的数。而如何求最小公倍数又要用到最大公约数的概念。a和b的最小公倍数就是axb/gcd(a, b)，其中gcd(a, b)即代表a和b的最大公约数。再然后，就是如何求最大公约数了，一个算法必备知识：<a href="https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95" target="_blank" rel="noopener">辗转相除法</a>。</p><p>上述过程可以求得给定一个数，小于等于这个数且能被给定3个数中任意一个数整除的数的个数。题目是要求第n个，而我们知道小于等于任意数有多少个，这就是典型的二分查找变种问题。好在题目给了结果的范围[1, 2000000000]，那么我们只要在这之间进行二分查找就好了。注意这里是找到满足条件的左边界问题，所以写法上要注意左右指针的取值。同时为了避免overflow，整个过程都是用长整型进行运算。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ab;</span><br><span class="line">    <span class="keyword">long</span> ac;</span><br><span class="line">    <span class="keyword">long</span> bc;</span><br><span class="line">    <span class="keyword">long</span> abc;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        ab = lcm(a, b);</span><br><span class="line">        ac = lcm(a, c);</span><br><span class="line">        bc = lcm(b, c);</span><br><span class="line">        abc = lcm(ab, c);</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">0</span>, r = <span class="number">2000000000</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">long</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> res = count(mid, a, b ,c);</span><br><span class="line">            <span class="keyword">if</span> (res &lt; n) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">lcm</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a*b / gcd(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> a, <span class="keyword">long</span> b, <span class="keyword">long</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n/a + n/b + n/c - n/ab - n/bc - n/ac + n/abc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href></a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Math </tag>
            
            <tag> Binary Search </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 18 4Sum</title>
      <link href="/2019/09/21/LeetCode-18-4Sum/"/>
      <url>/2019/09/21/LeetCode-18-4Sum/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 18 4Sum | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0018.png" width="75%" height="75%"><h2>解题思路</h2><p>思路和3Sum完全一样，只不过从锁定一个元素变成分别锁定两个元素。双指针的思路还是需要排序和去重。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> pLeft = j + <span class="number">1</span>, pRight = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (pLeft &lt; pRight) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] + nums[pLeft] + nums[pRight] &lt; target) &#123;</span><br><span class="line">                        pLeft++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[pLeft] + nums[pRight] &gt; target) &#123;</span><br><span class="line">                        pRight--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[i], nums[j], nums[pLeft++], nums[pRight--])));</span><br><span class="line">                        <span class="keyword">while</span> (pLeft &lt; pRight &amp;&amp; nums[pLeft] == nums[pLeft - <span class="number">1</span>]) &#123;</span><br><span class="line">                            pLeft++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (pLeft &lt; pRight &amp;&amp; nums[pRight] == nums[pRight + <span class="number">1</span>]) &#123;</span><br><span class="line">                            pRight--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href="https://tengdai722.github.io/2019/09/20/LeetCode-1-Two-Sum/" target="_blank" rel="noopener">LeetCode 1 Two Sum</a><br><a href="https://tengdai722.github.io/2019/09/21/LeetCode-15-3Sum/" target="_blank" rel="noopener">LeetCode 15 3Sum</a><br><a href></a><br><a href></a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Medium </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 15 3Sum</title>
      <link href="/2019/09/21/LeetCode-15-3Sum/"/>
      <url>/2019/09/21/LeetCode-15-3Sum/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 15 3Sum | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0015.png" width="75%" height="75%"><h2>解题思路</h2><p>2Sum进阶，先锁定一个元素变成2Sum，在剩下的元素里找可以加和成锁定元素相反数的两个元素。这里用到双指针的思路，分别从锁定元素的下一位以及数组尾部同时向中间移动。为了可以更高效的利用双指针，将输入数组进行排序。这样如果双指针加和小于目标元素(的相反数)，那么只需要移动左指针，反之亦然。考虑到重复的组合不可以被加入到答案中，每次扫描还需要进行去重的操作。那就是如果锁定的元素和上次的一样，要跳过。加和元素任意一个和上次一样，也同样跳过。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[i], pLeft = i + <span class="number">1</span>, pRight = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (pLeft &lt; pRight) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[pLeft] + nums[pRight] &lt; target) &#123;</span><br><span class="line">                pLeft++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[pLeft] + nums[pRight] &gt; target) &#123;</span><br><span class="line">                pRight--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[i], nums[pLeft++], nums[pRight--])));</span><br><span class="line">                    <span class="keyword">while</span> (pLeft &lt; pRight &amp;&amp; nums[pLeft] == nums[pLeft - <span class="number">1</span>]) &#123;</span><br><span class="line">                    pLeft++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (pRight &gt; pLeft &amp;&amp; nums[pRight] == nums[pRight + <span class="number">1</span>]) &#123;</span><br><span class="line">                    pRight--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href="https://tengdai722.github.io/2019/09/20/LeetCode-1-Two-Sum/" target="_blank" rel="noopener">LeetCode 1 Two Sum</a><br><a href="https://tengdai722.github.io/2019/09/21/LeetCode-18-4Sum/" target="_blank" rel="noopener">LeetCode 18 4Sum</a><br><a href></a><br><a href></a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Medium </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 刷题总结</title>
      <link href="/2019/09/21/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/21/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 刷题总结 | Java | 缓慢更新中</p><a id="more"></a><table><thead><tr><th style="text-align:center">No.</th><th style="text-align:center">Title</th><th style="text-align:center">Difficulty</th><th style="text-align:center">Solution</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Easy/" target="_blank" rel="noopener">Easy</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/20/LeetCode-1-Two-Sum/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">15</td><td style="text-align:center"><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">3Sum</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Medium/" target="_blank" rel="noopener">Medium</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/21/LeetCode-15-3Sum/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">18</td><td style="text-align:center"><a href="https://leetcode.com/problems/4sum/" target="_blank" rel="noopener">4Sum</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Medium/" target="_blank" rel="noopener">Medium</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/21/LeetCode-18-4Sum/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">167</td><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">Two Sum II - Input array is sorted</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Easy/" target="_blank" rel="noopener">Easy</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/23/LeetCode-167-Two-Sum-II-Input-array-is-sorted/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">170</td><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum-iii-data-structure-design/" target="_blank" rel="noopener">Two Sum III Data structure design</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Easy/" target="_blank" rel="noopener">Easy</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/23/LeetCode-170-Two-Sum-III-Data-structure-design/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">560</td><td style="text-align:center"><a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">Two Sum III Data structure design</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Medium/" target="_blank" rel="noopener">Medium</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/24/LeetCode-560-Subarray-Sum-Equals-K/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">653</td><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/" target="_blank" rel="noopener">Two Sum IV - Input is a BST</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Easy/" target="_blank" rel="noopener">Easy</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/24/LeetCode-653-Two-Sum-IV-Input-is-a-BST/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">1099</td><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum-less-than-k/" target="_blank" rel="noopener">Two Sum Less Than K</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Easy/" target="_blank" rel="noopener">Easy</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/24/LeetCode-1099-Two-Sum-Less-Than-K/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">1200</td><td style="text-align:center"><a href="https://leetcode.com/problems/minimum-absolute-difference/" target="_blank" rel="noopener">Minimum Absolute Difference</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Easy/" target="_blank" rel="noopener">Easy</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/23/LeetCode-1200-Minimum-Absolute-Difference/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">1201</td><td style="text-align:center"><a href="https://leetcode.com/problems/ugly-number-iii/" target="_blank" rel="noopener">Ugly Number III</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Medium/" target="_blank" rel="noopener">Medium</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/22/LeetCode-1201-Ugly-Number-III/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">1202</td><td style="text-align:center"><a href="https://leetcode.com/problems/smallest-string-with-swaps/" target="_blank" rel="noopener">Smallest String With Swaps</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Medium/" target="_blank" rel="noopener">Medium</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/22/LeetCode-1202-Smallest-String-With-Swaps/" target="_blank" rel="noopener">Solution</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1 Two Sum</title>
      <link href="/2019/09/20/LeetCode-1-Two-Sum/"/>
      <url>/2019/09/20/LeetCode-1-Two-Sum/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 1 Two Sum | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0001.png" width="75%" height="75%"><h2>解题思路</h2><p>题目假设只有一对答案，那么建立HashMap，每扫过一个元素，把target与当前元素的差当做key，下标当做value存入map。这样如果接下来扫到任何一个元素已经在map里面出现，证明它可以和之前扫过的一个元素形成答案。那么提取出存好的下标，和当前下标组成答案即可。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(nums[i]), i&#125;;</span><br><span class="line">            &#125; </span><br><span class="line">            map.put(target - nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href="https://tengdai722.github.io/2019/09/21/LeetCode-15-3Sum/" target="_blank" rel="noopener">LeetCode 15 3Sum</a><br><a href="https://tengdai722.github.io/2019/09/21/LeetCode-18-4Sum/" target="_blank" rel="noopener">LeetCode 18 4Sum</a><br><a href="https://tengdai722.github.io/2019/09/23/LeetCode-167-Two-Sum-II-Input-array-is-sorted/" target="_blank" rel="noopener">LeetCode 167 Two Sum II - Input array is sorted</a><br><a href="https://tengdai722.github.io/2019/09/23/LeetCode-170-Two-Sum-III-Data-structure-design/" target="_blank" rel="noopener">LeetCode 170 Two Sum III - Data structure design</a><br><a href="https://tengdai722.github.io/2019/09/24/LeetCode-560-Subarray-Sum-Equals-K/" target="_blank" rel="noopener">LeetCode 560 Subarray Sum Equals K</a><br><a href="https://tengdai722.github.io/2019/09/24/LeetCode-653-Two-Sum-IV-Input-is-a-BST/" target="_blank" rel="noopener">LeetCode 653 Two Sum IV - Input is a BST</a><br><a href="https://tengdai722.github.io/2019/09/24/LeetCode-1099-Two-Sum-Less-Than-K/" target="_blank" rel="noopener">LeetCode 1099 Two Sum Less Than K</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始Python实现卷积神经网络识别手写数字(MNIST)</title>
      <link href="/2019/09/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BPython%E5%AE%9E%E7%8E%B0%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97-MNIST/"/>
      <url>/2019/09/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BPython%E5%AE%9E%E7%8E%B0%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97-MNIST/</url>
      
        <content type="html"><![CDATA[<p>从零开始用Python实现一个卷积神经网络(CNN)来识别手写数字(MNIST)。代码 + 推导同时奉上。</p><a id="more"></a><p>卷积神经网络(Convolution Neural Network)是时下很流行的一种神经网络。时至今日我们已有很多框架可以进行卷积神经网络的构建和训练，但是很多时候<br>只知其表不知其里。这边文章来推导一下卷积神经网络的相关公式，并用只用Python(numpy)来实现一个简单的卷积神经网络对MNIST数据集进行训练和预测。</p><h2>卷积神经网络的推导</h2><p>推导过程清楚了之后开始我们的实现吧！</p><h2>卷积神经网络的实现</h2><p>推导过程清楚了之后开始我们的实现吧！</p><p>我们需要一个SimpleCNN类，并初始化需要的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCNN</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_dim=<span class="number">28</span>, num_class=<span class="number">10</span>, filter_size=<span class="number">3</span>, channel=<span class="number">3</span>)</span>:</span></span><br><span class="line">        self.input_dim = input_dim  <span class="comment"># 输入的维度，MNIST默认是28</span></span><br><span class="line">        self.num_class = num_class  <span class="comment"># 需要判断的类的数目，MNIST任务是10个，0-9</span></span><br><span class="line">        self.filter_size = filter_size  <span class="comment"># 卷积核的维度，这里取长宽相等，默认为3</span></span><br><span class="line">        self.channel = channel  <span class="comment"># 卷积核的深度(通道数)，默认3</span></span><br><span class="line">        self.output_dim = input_dim - filter_size + <span class="number">1</span>  <span class="comment"># 计算输出的维度，公式：N_out = N_input - D_kernel + 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化参数，这里用了Xavier初始化</span></span><br><span class="line">        self.kernel = np.random.uniform(<span class="number">-1</span>, <span class="number">1</span>, (self.filter_size, self.filter_size, self.channel)) * \</span><br><span class="line">                      math.sqrt(<span class="number">6.</span> / (input_dim + self.output_dim))</span><br><span class="line">        self.params_w = np.random.uniform(<span class="number">-1</span>, <span class="number">1</span>, (self.num_class, self.output_dim, self.output_dim, self.channel)) * \</span><br><span class="line">                        math.sqrt(<span class="number">6.</span> / (self.input_dim + self.output_dim))</span><br><span class="line">        self.params_b = np.random.uniform(<span class="number">-1</span>, <span class="number">1</span>, self.num_class)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
