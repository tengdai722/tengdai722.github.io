<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode 2 Add Two Numbers</title>
      <link href="/2019/09/24/LeetCode-2-Add-Two-Numbers/"/>
      <url>/2019/09/24/LeetCode-2-Add-Two-Numbers/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 2 Add Two Numbers | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0002.png" width="75%" height="75%"><h2>解题思路</h2><p>基础链表题。逐位相加，记录进位，直到加完两个输入链表的节点。最后检验是否还有进位即可。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode res = <span class="keyword">new</span> ListNode(<span class="number">0</span>), cur = res;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d1 = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="keyword">int</span> d2 = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="keyword">int</span> sum = d1 + d2 + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p>[]</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Math </tag>
            
            <tag> Medium </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1099 Two Sum Less Than K</title>
      <link href="/2019/09/24/LeetCode-1099-Two-Sum-Less-Than-K/"/>
      <url>/2019/09/24/LeetCode-1099-Two-Sum-Less-Than-K/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 1099 Two Sum Less Than K | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC1099.png" width="75%" height="75%"><h2>解题思路</h2><p>又是two sum变体，更接近<a href="https://tengdai722.github.io/2019/09/23/LeetCode-167-Two-Sum-II-Input-array-is-sorted/" target="_blank" rel="noopener">LeetCode 167</a>。只要排序之后利用双指针即可。前后扫描，之后取最大的值，否则返回-1。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">twoSumLessThanK</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="keyword">int</span> pLeft = <span class="number">0</span>, pRight = A.length - <span class="number">1</span>, res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (pLeft &lt; pRight) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[pLeft] + A[pRight] &gt;= K) &#123;</span><br><span class="line">                pRight--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = Math.max(res, A[pLeft] + A[pRight]);</span><br><span class="line">                pLeft++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href="https://tengdai722.github.io/2019/09/20/LeetCode-1-Two-Sum/" target="_blank" rel="noopener">LeetCode 1 Two Sum</a><br><a href="https://tengdai722.github.io/2019/09/23/LeetCode-167-Two-Sum-II-Input-array-is-sorted/" target="_blank" rel="noopener">LeetCode 167 Two Sum II - Input array is sorted</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 653 Two Sum IV - Input is a BST</title>
      <link href="/2019/09/24/LeetCode-653-Two-Sum-IV-Input-is-a-BST/"/>
      <url>/2019/09/24/LeetCode-653-Two-Sum-IV-Input-is-a-BST/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 653 Two Sum IV - Input is a BST | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0653_1.png" width="75%" height="75%"><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0653_2.png" width="75%" height="75%"><h2>解题思路</h2><p>如果利用BST的性质，完全可以做中序遍历，直接得到有序的序列，之后进行双指针操作。也可以直接扫描所有的节点，之后利用set将结果存储起来，每次找到可以满足条件的节点就返回，否则存下当前节点并继续扫描。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(k - root.val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> findTarget(root.left, k) || findTarget(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href="https://tengdai722.github.io/2019/09/20/LeetCode-1-Two-Sum/" target="_blank" rel="noopener">LeetCode 1 Two Sum</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Easy </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 560 Subarray Sum Equals K</title>
      <link href="/2019/09/24/LeetCode-560-Subarray-Sum-Equals-K/"/>
      <url>/2019/09/24/LeetCode-560-Subarray-Sum-Equals-K/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 560 Subarray Sum Equals K | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0560.png" width="75%" height="75%"><h2>解题思路</h2><p>又是加和等于特定目标的题。首先想一下暴力解法，可以$O(n^2)$实现，即每次固定子数组的首，之后依次判断每一个尾位置是否满足条件。这样的话，每次都要计算首尾之间的加和，多了很多重复的计算。那么如果我们提前计算出以每个位置为结尾，到数组起始位置元素和的话，也就是计算sum数组，那么sum数组任何两个位置元素的差值，就是子数组的和了。也就是说，我们有一个累计加和(sum)数组之后，就可以利用two sum的思想，在这个数组里找到做差为target的位置。又因为sum数组是可以实时更新的，所以我们并不需要开辟新的空间去存储，而是边算边存到map里面，这样一旦我们找到了满足条件的位置，就可以计入最后的结果。因为我们最后要统计个数，所以map里面存的key是从起点到数组每一个位置的元素的和，value是这个和出现的个数。这是因为不同的子数组完全可以产生同样的加和。初始化map需要把(0, 1)加入map，因为当什么都没有的时候，空子数组加和就是0。剩下的就和two sum一样，只是求和变成了求差。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum - k)) &#123;</span><br><span class="line">                res += map.get(sum - k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href="https://tengdai722.github.io/2019/09/20/LeetCode-1-Two-Sum/" target="_blank" rel="noopener">LeetCode 1 Two Sum</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 170 Two Sum III - Data structure design</title>
      <link href="/2019/09/23/LeetCode-170-Two-Sum-III-Data-structure-design/"/>
      <url>/2019/09/23/LeetCode-170-Two-Sum-III-Data-structure-design/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 170 Two Sum III - Data structure design | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0170.png" width="75%" height="75%"><h2>解题思路</h2><p>和基础Two Sum想法一样，只不过要注意重复的问题。比如map里只有一个0，那么当value是0的时候还是要返回false，因为只有一个数不满足条件，必须要两个数加和才可以。所以这样的话要记录同样数字的个数。如果加和等于目标的数对是同一个数字，要看map里面是不是有至少两个这样的数。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add the number to an internal data structure.. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        map.put(number, map.getOrDefault(number, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Find if there exists any pair of numbers which sum is equal to the value. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num1 : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> num2 = value - num1;</span><br><span class="line">            <span class="keyword">if</span> (num1 == num2 &amp;&amp; map.get(num1) &gt; <span class="number">1</span> || num1 != num2 &amp;&amp; map.containsKey(num2)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TwoSum object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TwoSum obj = new TwoSum();</span></span><br><span class="line"><span class="comment"> * obj.add(number);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.find(value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href="https://tengdai722.github.io/2019/09/20/LeetCode-1-Two-Sum/" target="_blank" rel="noopener">LeetCode 1 Two Sum</a><br><a href></a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Easy </tag>
            
            <tag> Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 167 Two Sum II - Input array is sorted</title>
      <link href="/2019/09/23/LeetCode-167-Two-Sum-II-Input-array-is-sorted/"/>
      <url>/2019/09/23/LeetCode-167-Two-Sum-II-Input-array-is-sorted/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 167 Two Sum II - Input array is sorted | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0167.png" width="75%" height="75%"><h2>解题思路</h2><p>排过序的数组直接用双指针扫描即可。也可以固定一个数，另一个数用二分查找，只是稍慢一点。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; numbers[i] != target - numbers[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &gt; target - numbers[j]) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = &#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href="https://tengdai722.github.io/2019/09/20/LeetCode-1-Two-Sum/" target="_blank" rel="noopener">LeetCode 1 Two Sum</a><br><a href></a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
            <tag> Binary Search </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1200 Minimum Absolute Difference</title>
      <link href="/2019/09/23/LeetCode-1200-Minimum-Absolute-Difference/"/>
      <url>/2019/09/23/LeetCode-1200-Minimum-Absolute-Difference/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 1200 Minimum Absolute Difference | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC1200_1.png" width="75%" height="75%"><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC1200_2.png" width="75%" height="75%"><h2>解题思路</h2><p>排序后第一遍扫描找到最小差值，第二遍扫描找到所有相差为最小差值的数对即可。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; minimumAbsDifference(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> minDiff = arr[<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minDiff &gt; arr[i] - arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                minDiff = arr[i] - arr[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] - arr[i - <span class="number">1</span>] == minDiff) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(arr[i - <span class="number">1</span>], arr[i])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href></a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1202 Smallest String With Swaps</title>
      <link href="/2019/09/22/LeetCode-1202-Smallest-String-With-Swaps/"/>
      <url>/2019/09/22/LeetCode-1202-Smallest-String-With-Swaps/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 1202 Smallest String With Swaps | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC1202_1.png" width="75%" height="75%"><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC1202_2.png" width="75%" height="75%"><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC1202_3.png" width="75%" height="75%"><h2>解题思路</h2><p>看到pair有的时候潜意识就会有种反射会想到图。具体怎么想到的呢？通过读题我们可以知道同一个位置可以和多个位置进行互换，那么通过足够多的互换，只要是连在一起的位置就都可以互相替换。也就是说互换的位置是可以传递的。既然如此，首先我们要知道哪些位置是互相连通的，也就是说，我们要找到所有“连在一起”的位置。想到这就更自然的往连通图和union find的方向思考了。</p><p>如果我们通过union find找到了所有连在一起的位置，那么接下来用贪心的思维直接去找每个位置字典序最小的字母就好。其实这里需要用数学归纳法证明一下如果n个位置可以连通互换，那么这n个位置的字母可以组成长度为n的全排列。也就是说，直接贪心是一定可以组成我们想要的字典序最小的排列的。最后对于每一个连通子图，把图里面的字母存到优先队列里就可以了，每次只拿最小的，那么当所有字母取完之后就是我们想要的最优答案。</p><p>这道题真的是非常好的一道题，逻辑思维，图，哈希表，和优先队列，全都考到了。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">smallestStringWithSwaps</span><span class="params">(String s, List&lt;List&lt;Integer&gt;&gt; pairs)</span> </span>&#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; pair : pairs) &#123;</span><br><span class="line">            union(pair.get(<span class="number">0</span>), pair.get(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        HashMap&lt;Integer, PriorityQueue&lt;Character&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> root = find(i);</span><br><span class="line">            id[i] = root;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(root)) &#123;</span><br><span class="line">                map.put(root, <span class="keyword">new</span> PriorityQueue&lt;Character&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(root).add(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            sb.append(map.get(id[i]).poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id[p] == p) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">int</span> q = find(id[p]);</span><br><span class="line">        id[p] = q;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pId = find(p);</span><br><span class="line">        <span class="keyword">int</span> qId = find(q);</span><br><span class="line">        <span class="keyword">if</span> (pId == qId) <span class="keyword">return</span>;</span><br><span class="line">        id[pId] = qId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href></a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Medium </tag>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1201 Ugly Number III</title>
      <link href="/2019/09/22/LeetCode-1201-Ugly-Number-III/"/>
      <url>/2019/09/22/LeetCode-1201-Ugly-Number-III/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 1201 Ugly Number III | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC1201_1.png" width="75%" height="75%"><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC1201_2.png" width="75%" height="75%"><h2>解题思路</h2><p>丑数2的升级版，又略有不同。之前的丑数都是找约数只是给定数字的数，而这次是只要能整除给定数字就可以，所以算是有一些区别。一开始用丑数2的思路一个个判断和找，果然超时了。既然是找个数，那能不能提前统计一下满足条件的数的个数呢，即给定一个数，小于等于这个数且能被给定3个数中任意一个数整除的数有多少呢？举例子，比如12，小于等于12，且能被2，3，4中任意一个整除的数有几个？这就用到了集合的<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%AE%B9%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">容斥原理</a>。即我们要求的满足条件数的个数，等于能被2整除的数 + 能被3整除的数 + 能被4整除的数 - 能被2，3同时整除的数 - 能被2，4同时整除的数 - 能被3，4同时整除的数 + 能被2，3，4同时整除的的数。如何求能同时被两个数整除的数呢？这里需要用到最小公倍数的概念，即想要求能被a和b同时整除的，且小于等于N的数的个数，做法是找到a和b的最小公倍数ab，之后N/ab就是所求的数。而如何求最小公倍数又要用到最大公约数的概念。a和b的最小公倍数就是axb/gcd(a, b)，其中gcd(a, b)即代表a和b的最大公约数。再然后，就是如何求最大公约数了，一个算法必备知识：<a href="https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95" target="_blank" rel="noopener">辗转相除法</a>。</p><p>上述过程可以求得给定一个数，小于等于这个数且能被给定3个数中任意一个数整除的数的个数。题目是要求第n个，而我们知道小于等于任意数有多少个，这就是典型的二分查找变种问题。好在题目给了结果的范围[1, 2000000000]，那么我们只要在这之间进行二分查找就好了。注意这里是找到满足条件的左边界问题，所以写法上要注意左右指针的取值。同时为了避免overflow，整个过程都是用长整型进行运算。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ab;</span><br><span class="line">    <span class="keyword">long</span> ac;</span><br><span class="line">    <span class="keyword">long</span> bc;</span><br><span class="line">    <span class="keyword">long</span> abc;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        ab = lcm(a, b);</span><br><span class="line">        ac = lcm(a, c);</span><br><span class="line">        bc = lcm(b, c);</span><br><span class="line">        abc = lcm(ab, c);</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">0</span>, r = <span class="number">2000000000</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">long</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> res = count(mid, a, b ,c);</span><br><span class="line">            <span class="keyword">if</span> (res &lt; n) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">lcm</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a*b / gcd(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> a, <span class="keyword">long</span> b, <span class="keyword">long</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n/a + n/b + n/c - n/ab - n/bc - n/ac + n/abc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href></a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Math </tag>
            
            <tag> Binary Search </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 18 4Sum</title>
      <link href="/2019/09/21/LeetCode-18-4Sum/"/>
      <url>/2019/09/21/LeetCode-18-4Sum/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 18 4Sum | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0018.png" width="75%" height="75%"><h2>解题思路</h2><p>思路和3Sum完全一样，只不过从锁定一个元素变成分别锁定两个元素。双指针的思路还是需要排序和去重。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> pLeft = j + <span class="number">1</span>, pRight = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (pLeft &lt; pRight) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] + nums[pLeft] + nums[pRight] &lt; target) &#123;</span><br><span class="line">                        pLeft++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[pLeft] + nums[pRight] &gt; target) &#123;</span><br><span class="line">                        pRight--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[i], nums[j], nums[pLeft++], nums[pRight--])));</span><br><span class="line">                        <span class="keyword">while</span> (pLeft &lt; pRight &amp;&amp; nums[pLeft] == nums[pLeft - <span class="number">1</span>]) &#123;</span><br><span class="line">                            pLeft++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (pLeft &lt; pRight &amp;&amp; nums[pRight] == nums[pRight + <span class="number">1</span>]) &#123;</span><br><span class="line">                            pRight--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href="https://tengdai722.github.io/2019/09/20/LeetCode-1-Two-Sum/" target="_blank" rel="noopener">LeetCode 1 Two Sum</a><br><a href="https://tengdai722.github.io/2019/09/21/LeetCode-15-3Sum/" target="_blank" rel="noopener">LeetCode 15 3Sum</a><br><a href></a><br><a href></a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Medium </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 15 3Sum</title>
      <link href="/2019/09/21/LeetCode-15-3Sum/"/>
      <url>/2019/09/21/LeetCode-15-3Sum/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 15 3Sum | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0015.png" width="75%" height="75%"><h2>解题思路</h2><p>2Sum进阶，先锁定一个元素变成2Sum，在剩下的元素里找可以加和成锁定元素相反数的两个元素。这里用到双指针的思路，分别从锁定元素的下一位以及数组尾部同时向中间移动。为了可以更高效的利用双指针，将输入数组进行排序。这样如果双指针加和小于目标元素(的相反数)，那么只需要移动左指针，反之亦然。考虑到重复的组合不可以被加入到答案中，每次扫描还需要进行去重的操作。那就是如果锁定的元素和上次的一样，要跳过。加和元素任意一个和上次一样，也同样跳过。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[i], pLeft = i + <span class="number">1</span>, pRight = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (pLeft &lt; pRight) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[pLeft] + nums[pRight] &lt; target) &#123;</span><br><span class="line">                pLeft++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[pLeft] + nums[pRight] &gt; target) &#123;</span><br><span class="line">                pRight--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[i], nums[pLeft++], nums[pRight--])));</span><br><span class="line">                    <span class="keyword">while</span> (pLeft &lt; pRight &amp;&amp; nums[pLeft] == nums[pLeft - <span class="number">1</span>]) &#123;</span><br><span class="line">                    pLeft++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (pRight &gt; pLeft &amp;&amp; nums[pRight] == nums[pRight + <span class="number">1</span>]) &#123;</span><br><span class="line">                    pRight--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href="https://tengdai722.github.io/2019/09/20/LeetCode-1-Two-Sum/" target="_blank" rel="noopener">LeetCode 1 Two Sum</a><br><a href="https://tengdai722.github.io/2019/09/21/LeetCode-18-4Sum/" target="_blank" rel="noopener">LeetCode 18 4Sum</a><br><a href></a><br><a href></a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Medium </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 刷题总结</title>
      <link href="/2019/09/21/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/21/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 刷题总结 | Java | 缓慢更新中</p><a id="more"></a><table><thead><tr><th style="text-align:center">No.</th><th style="text-align:center">Title</th><th style="text-align:center">Difficulty</th><th style="text-align:center">Solution</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Easy/" target="_blank" rel="noopener">Easy</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/20/LeetCode-1-Two-Sum/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center"><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">Two Sum</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Medium/" target="_blank" rel="noopener">Medium</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/24/LeetCode-2-Add-Two-Numbers/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">15</td><td style="text-align:center"><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">3Sum</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Medium/" target="_blank" rel="noopener">Medium</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/21/LeetCode-15-3Sum/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">18</td><td style="text-align:center"><a href="https://leetcode.com/problems/4sum/" target="_blank" rel="noopener">4Sum</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Medium/" target="_blank" rel="noopener">Medium</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/21/LeetCode-18-4Sum/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">167</td><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">Two Sum II - Input array is sorted</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Easy/" target="_blank" rel="noopener">Easy</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/23/LeetCode-167-Two-Sum-II-Input-array-is-sorted/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">170</td><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum-iii-data-structure-design/" target="_blank" rel="noopener">Two Sum III Data structure design</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Easy/" target="_blank" rel="noopener">Easy</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/23/LeetCode-170-Two-Sum-III-Data-structure-design/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">560</td><td style="text-align:center"><a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">Two Sum III Data structure design</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Medium/" target="_blank" rel="noopener">Medium</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/24/LeetCode-560-Subarray-Sum-Equals-K/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">653</td><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/" target="_blank" rel="noopener">Two Sum IV - Input is a BST</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Easy/" target="_blank" rel="noopener">Easy</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/24/LeetCode-653-Two-Sum-IV-Input-is-a-BST/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">1099</td><td style="text-align:center"><a href="https://leetcode.com/problems/two-sum-less-than-k/" target="_blank" rel="noopener">Two Sum Less Than K</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Easy/" target="_blank" rel="noopener">Easy</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/24/LeetCode-1099-Two-Sum-Less-Than-K/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">1200</td><td style="text-align:center"><a href="https://leetcode.com/problems/minimum-absolute-difference/" target="_blank" rel="noopener">Minimum Absolute Difference</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Easy/" target="_blank" rel="noopener">Easy</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/23/LeetCode-1200-Minimum-Absolute-Difference/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">1201</td><td style="text-align:center"><a href="https://leetcode.com/problems/ugly-number-iii/" target="_blank" rel="noopener">Ugly Number III</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Medium/" target="_blank" rel="noopener">Medium</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/22/LeetCode-1201-Ugly-Number-III/" target="_blank" rel="noopener">Solution</a></td></tr><tr><td style="text-align:center">1202</td><td style="text-align:center"><a href="https://leetcode.com/problems/smallest-string-with-swaps/" target="_blank" rel="noopener">Smallest String With Swaps</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/tags/Medium/" target="_blank" rel="noopener">Medium</a></td><td style="text-align:center"><a href="https://tengdai722.github.io/2019/09/22/LeetCode-1202-Smallest-String-With-Swaps/" target="_blank" rel="noopener">Solution</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1 Two Sum</title>
      <link href="/2019/09/20/LeetCode-1-Two-Sum/"/>
      <url>/2019/09/20/LeetCode-1-Two-Sum/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 1 Two Sum | 问题描述 | 解题思路 | Java代码 | 相关问题</p><a id="more"></a><h2>问题描述</h2><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/leetcode_question/LC0001.png" width="75%" height="75%"><h2>解题思路</h2><p>题目假设只有一对答案，那么建立HashMap，每扫过一个元素，把target与当前元素的差当做key，下标当做value存入map。这样如果接下来扫到任何一个元素已经在map里面出现，证明它可以和之前扫过的一个元素形成答案。那么提取出存好的下标，和当前下标组成答案即可。</p><h2>Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(nums[i]), i&#125;;</span><br><span class="line">            &#125; </span><br><span class="line">            map.put(target - nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>相关问题</h2><p><a href="https://tengdai722.github.io/2019/09/21/LeetCode-15-3Sum/" target="_blank" rel="noopener">LeetCode 15 3Sum</a><br><a href="https://tengdai722.github.io/2019/09/21/LeetCode-18-4Sum/" target="_blank" rel="noopener">LeetCode 18 4Sum</a><br><a href="https://tengdai722.github.io/2019/09/23/LeetCode-167-Two-Sum-II-Input-array-is-sorted/" target="_blank" rel="noopener">LeetCode 167 Two Sum II - Input array is sorted</a><br><a href="https://tengdai722.github.io/2019/09/23/LeetCode-170-Two-Sum-III-Data-structure-design/" target="_blank" rel="noopener">LeetCode 170 Two Sum III - Data structure design</a><br><a href="https://tengdai722.github.io/2019/09/24/LeetCode-560-Subarray-Sum-Equals-K/" target="_blank" rel="noopener">LeetCode 560 Subarray Sum Equals K</a><br><a href="https://tengdai722.github.io/2019/09/24/LeetCode-653-Two-Sum-IV-Input-is-a-BST/" target="_blank" rel="noopener">LeetCode 653 Two Sum IV - Input is a BST</a><br><a href="https://tengdai722.github.io/2019/09/24/LeetCode-1099-Two-Sum-Less-Than-K/" target="_blank" rel="noopener">LeetCode 1099 Two Sum Less Than K</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Array </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始Python实现卷积神经网络识别手写数字(MNIST)</title>
      <link href="/2019/09/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BPython%E5%AE%9E%E7%8E%B0%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97-MNIST/"/>
      <url>/2019/09/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8BPython%E5%AE%9E%E7%8E%B0%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97-MNIST/</url>
      
        <content type="html"><![CDATA[<p>Python手写CNN | CNN推导 | Python代码 | MNIST数字识别</p><a id="more"></a><p>卷积神经网络(Convolution Neural Network)是时下很流行的一种神经网络。时至今日我们已有很多框架可以进行卷积神经网络的构建和训练，但是很多时候<br>只知其表不知其里。这边文章来推导一下卷积神经网络的相关公式，并用只用Python(numpy)来实现一个简单的卷积神经网络对MNIST数据集进行训练和预测。</p><h2>数学推导</h2><p>作为卷积神经网络的重要操作，我们首先定义卷积运算。这里不再详细介绍什么是深度神经网络里面的卷积，我们就把它当做一个filter操作。多通道卷积操作定义如下：<br>$$(X * K)_{i, j, c}=\sum_{m = 0}^{k_y - 1}\sum_{n = 0}^{k_x - 1}K_{m, n, c}X_{i + m, j + n}\qquad\qquad(1)$$<br>接下来，我们定义在某一层里，输出为$Z$，输入为$X$，那么：<br>$$Z_{:,:,c} = X_{:,:} * K_{:,:,c}\qquad\qquad(2)$$<br>即把输入$X$用卷积作用，提取feature map作为$Z$。接下来作用激活函数(activation function) $\sigma(\cdot)$ 来引入nonlinearity：<br>$$H_{:,;,c} = \sigma(Z_{:,:,c})\qquad\qquad(3)$$<br>最后，我们用全连接层(fully connection layer)来把神经网络的结果和我们要分类的结果连起来，再作用softmax得到概率(其中$\odot$是element wise multiplication，$W_{k,:,:,:} \odot H = \sum_{i, j, c}W_{k,i,j,c}H_{i,j,c})$：<br>$$U_k=W_{k,:,:,:}\odot H+b_k\qquad\qquad(4)$$$$f(x;\theta)=F_{softmax}(U)\qquad\qquad(5)$$<br>上述整个过程就是神经网络里面的forward propagation，向前传播。即通过对输入的卷积处理，激活，全连接，最后得到分类概率。而其中的参数集合$\theta=$ {$K, W, b_{k}$} 就是我们需要通过训练获得的。对于接下来matrix level的推导以及Python实现，我们把每一步的矩阵维度列出来，这样能更好的帮助我们理解：<br>$$公式(2)\qquad Z \in R^{(d-k_y+1) \times (d-k_x+1) \times c} = X \in R^{d \times d } * K \in R^{k_y \times k_x \times c}$$$$公式(3)\qquad H \in R^{(d-k_y+1) \times (d-k_x+1) \times c} = \sigma(Z \in R^{(d-k_y+1) \times (d-k_x+1) \times c})$$$$公式(4)\qquad U \in R^{k \times 1}=W \in R^{k \times (d-k_y+1) \times (d-k_x+1) \times c}\odot H \in R^{(d-k_y+1) \times (d-k_x+1) \times c} + b_k \in R^{k \times 1}$$$$公式(5)\qquad f(x;\theta) \in R^{k \times 1}=F_{softmax}(U \in R^{k \times 1})$$<br>其中公式(2)中，d为输入的维度(假设单通道，宽高相等)，$k_y$与$k_x$为卷积核的维度，那么卷积操作的输出即为$\frac{d - k_{x \ or \  y} + 2 \times padding}{stride} + 1$。我们这里假设padding(卷积操作对输入边缘的补偿元素)为0，stride(卷积操作的步长)为1，即可得到上面$Z$的维度。$k$是类别总数。比如MNIST识别手写数字，$k$就是10。</p><p>理清了向前传播，下面开始我们推导反向传播。首先我们定义我们的目标函数，也就是所谓的loss function：<br>$$\rho := \rho(f(X;\theta), Y) = -log(f_Y(X;\theta))\qquad\qquad(6)$$<br>我们的目的就是通过stochastic gradient descent去逐渐的更新函数中的参数来降低loss。既然是计算梯度下降，我们必然要计算目标函数对于神经网络中各个参数的偏导数。因为整个网络有很多参数互相嵌套，所以我们要利用链式法则逐渐的拆分参数，第一步：<br>$$\frac{\partial \rho}{\partial U} = -(e(Y) - f(X; \theta))\qquad\qquad(7)$$<br>其中$e(Y)$的作用是将一个data sample的label部分从代表其分类的数变成一个$R^{k \times 1}$的列向量，这个列向量只有第$k$项是1，其他都是0，k的取值范围是0-9，代表0-9这10个数字。</p><p>根据链式法则，我们会得出：<br>$$\frac{\partial \rho}{\partial b_k}=\frac{\partial \rho}{\partial U}\frac{\partial U}{\partial b_k}=\frac{\partial \rho}{\partial U}\qquad\qquad(8)$$$$\frac{\partial \rho}{\partial W_{k,:,:,:}}=\frac{\partial \rho}{\partial U_k}\frac{\partial U_k}{\partial W_{k,:,:,:}}=\frac{\partial \rho}{\partial U_k} H\qquad\qquad(9)$$<br>目前到这里都很直白，下面我们计算稍稍复杂一点的loss function对卷积核K的偏导数，首先我们要先定义：<br>$$\delta_{i, j, c} = \frac{\partial \rho}{\partial H_{i, j, c}} = \sum_{k=0}^{number\ of\ class - 1}\frac{\partial \rho}{\partial U_k} \odot W_{k, i, j, c}\qquad\qquad(10)$$<br>这一步定义了loss function对全连接层输入$H$的偏导数。基于此，我们可以通过链式法则求出：</p><p>$$\frac{\partial \rho}{\partial K_{i, j, c}} = \sum_{m = 0}^{d - k_y}\sum_{n = 0}^{d - k_x}\delta_{m, n}\frac{\partial H_{m, n, p}}{\partial K_{i, j, c}} $$ $$ = \sum_{m = 0}^{d - k_y}\sum_{n = 0}^{d - k_x}\delta_{m, n}\sigma\prime(Z_{m, n, c})X_{i+m, j+n}$$ $$ =X_{i:i+d-k_y,j:j+d-k_x}\cdot (\sigma\prime(Z_c)\odot\delta) $$ $$ = (X * (\sigma\prime(Z)\odot\delta))_{i, j, c}$$ $$Therefore, \frac{\partial \rho}{\partial K} = X * (\sigma\prime(Z)\odot\delta)\qquad\qquad(11)$$</p><p>至此，我们需要的参数对于loss function的偏导数就都求出来了。那么我们每次将旧参数与learning rate和对应偏导数的乘积做差，即可每次更新所求的参数，直到训练得到满意的结果($\alpha$为learning rate)：<br>$$\theta = \theta - \alpha \frac{\partial\rho}{\partial\theta}\qquad\qquad(12)$$<br>以上就是神经网络的反向传播(back propagation)。通过反向传播，我们每次更新需要训练的参数，直到训练完成。</p><h2>Python实现</h2><p>推导过程清楚了之后，剩下的就是Python实现了。实践出真知，所以就算上面推导看的一头雾水，结合代码还是可以加深理解。推荐把上面的推导和下面的代码结合起来看。</p><p>以下的实现代码用了ReLU作为激活函数。为了加速卷积操作，下面的实现利用了矩阵加速。一些解释见这个链接：<a href="https://www.cnblogs.com/hejunlin1992/p/8686838.html" target="_blank" rel="noopener">https://www.cnblogs.com/hejunlin1992/p/8686838.html</a></p><p>用的MNIST HDF5格式的数据集可以<a href="https://github.com/tengdai722/tengdai722.github.io/raw/master/files/MNISTdata.hdf5" target="_blank" rel="noopener">点此下载</a>。</p><p>完整卷积神经网络(生成、训练、测试)代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> h5py</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCNN</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_dim=<span class="number">28</span>, num_class=<span class="number">10</span>, filter_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>, channel=<span class="number">3</span>)</span>:</span></span><br><span class="line">        self.input_dim = input_dim</span><br><span class="line">        self.num_class = num_class</span><br><span class="line">        self.filter_size = filter_size</span><br><span class="line">        self.stride = stride</span><br><span class="line">        self.padding = padding</span><br><span class="line">        self.channel = channel</span><br><span class="line"></span><br><span class="line">        self.output_dim = (input_dim - filter_size + <span class="number">2</span> * padding) // stride + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        self.kernel = np.random.uniform(<span class="number">-1</span>, <span class="number">1</span>, (self.filter_size, self.filter_size, self.channel)) * \</span><br><span class="line">                      math.sqrt(<span class="number">6.</span> / (input_dim + self.output_dim))</span><br><span class="line">        self.params_w = np.random.uniform(<span class="number">-1</span>, <span class="number">1</span>, (self.num_class, self.output_dim, self.output_dim, self.channel)) * \</span><br><span class="line">                        math.sqrt(<span class="number">6.</span> / (self.input_dim + self.output_dim))</span><br><span class="line">        self.params_b = np.random.uniform(<span class="number">-1</span>, <span class="number">1</span>, self.num_class)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward_prop</span><span class="params">(self, data_x)</span>:</span></span><br><span class="line">        data_x = self.reshap_square(data_x)</span><br><span class="line">        z = self.conv(data_x, self.kernel)</span><br><span class="line">        h = self.relu(z)</span><br><span class="line">        u = np.zeros(self.num_class)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(self.channel):</span><br><span class="line">            u += np.sum(np.multiply(self.params_w[:, :, :, c], h[:, :, c]), axis=(<span class="number">1</span>, <span class="number">2</span>)) + self.params_b</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> u, h, z, self.softmax(u)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backword_prop</span><span class="params">(self, data_x, data_y)</span>:</span></span><br><span class="line">        data_x = self.reshap_square(data_x)</span><br><span class="line">        u, h, z, f = self.forward_prop(data_x)</span><br><span class="line">        grad_w = np.zeros(self.params_w.shape)</span><br><span class="line">        rho_u = self.get_error(f, data_y)</span><br><span class="line">        grad_b = rho_u</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cls <span class="keyword">in</span> range(self.num_class):</span><br><span class="line">            grad_w[cls] = rho_u[cls] * h</span><br><span class="line"></span><br><span class="line">        delta = np.sum(np.multiply(np.reshape(rho_u, (self.num_class, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)), self.params_w), axis=<span class="number">0</span>)</span><br><span class="line">        print(h.shape)</span><br><span class="line">        grad_k = self.conv(data_x, np.multiply(self.relu_deriv(z), delta))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grad_w, grad_b, grad_k</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_params</span><span class="params">(self, data_x, data_y, lr)</span>:</span></span><br><span class="line">        grad_w, grad_b, grad_k = self.backword_prop(data_x, data_y)</span><br><span class="line">        self.params_w -= lr * grad_w</span><br><span class="line">        self.params_b -= lr * grad_b</span><br><span class="line">        self.kernel -= lr * grad_k</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(self, x, kernel)</span>:</span></span><br><span class="line">        filter_size, _, channel = kernel.shape</span><br><span class="line">        input_dim = x.shape[<span class="number">0</span>]</span><br><span class="line">        output_dim = input_dim - filter_size + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># M * K: M = number of kernel, K = kernel_size * kernel_size</span></span><br><span class="line">        kernel_vec = np.zeros((channel, filter_size * filter_size))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># K * N: K = kernel_size * kernel_size, N = output_dim * output_dim</span></span><br><span class="line">        input_vec = np.zeros((filter_size * filter_size, output_dim * output_dim))</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span><br><span class="line">            kernel_vec[c] = kernel[:, :, c].flatten()</span><br><span class="line"></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(output_dim):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(output_dim):</span><br><span class="line">                input_vec[:, idx] = x[i:i + filter_size, j:j + filter_size].flatten()</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># M * N: number of kernel x output_vec, need to be transposed to N * M</span></span><br><span class="line">        res = np.dot(kernel_vec, input_vec)</span><br><span class="line">        <span class="keyword">return</span> np.reshape(res.T, (output_dim, output_dim, channel))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_error</span><span class="params">(self, U, data_y)</span>:</span></span><br><span class="line">        e_y = np.zeros(self.num_class)</span><br><span class="line">        e_y[data_y] = <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">return</span> U - e_y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(self, z)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.maximum(z, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">relu_deriv</span><span class="params">(self, z)</span>:</span></span><br><span class="line">        z[z &gt;= <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        z[z &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(self, z)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.exp(z) / np.sum(np.exp(z))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_loss</span><span class="params">(self, data_x, data_y)</span>:</span></span><br><span class="line">        N = len(data_y)</span><br><span class="line">        loss = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(data_x, data_y):</span><br><span class="line">            _, _, _, pred = self.forward_prop(x)</span><br><span class="line">            loss += -np.log(pred)[y]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loss / N</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_accuracy</span><span class="params">(self, test_x, test_y)</span>:</span></span><br><span class="line">        N = len(test_y)</span><br><span class="line">        test_pred = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> test_x:</span><br><span class="line">            _, _, _, pred = self.forward_prop(x)</span><br><span class="line">            test_pred.append(np.argmax(pred))</span><br><span class="line">        <span class="keyword">return</span> sum(int(x == y) <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(test_pred, test_y)) / N</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reshap_square</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.reshape(x, (self.input_dim, self.input_dim))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, data_x, data_y, epochs, lr, loss_rec=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              training_acc_rec=<span class="number">1</span>, test_acc_rec=<span class="number">1</span>, decay_rate=<span class="number">0.5</span>, decay_step=<span class="number">10</span>, test_x=None, test_y=None)</span>:</span></span><br><span class="line">        training_loss = []</span><br><span class="line">        training_accuracy = []</span><br><span class="line">        test_accuracy = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> itr <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1</span> + epochs):</span><br><span class="line">            start_time = time.time()</span><br><span class="line">            <span class="keyword">if</span> itr % decay_step == <span class="number">0</span>:</span><br><span class="line">                lr *= decay_rate</span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(data_x, data_y):</span><br><span class="line">                self.update_params(x, y, lr)</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            print(<span class="string">"Epoch &#123;&#125; completed with learning rate &#123;&#125;"</span>.format(itr, lr))</span><br><span class="line">            print(<span class="string">"Time used to complete this epoch: &#123;&#125; seconds"</span>.format(end_time - start_time))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> itr % loss_rec == <span class="number">0</span>:</span><br><span class="line">                loss = self.calc_loss(data_x, data_y)</span><br><span class="line">                print(<span class="string">"Loss for epoch &#123;&#125;: &#123;&#125;"</span>.format(itr, loss))</span><br><span class="line">                training_loss.append(loss)</span><br><span class="line">            <span class="keyword">if</span> itr % training_acc_rec == <span class="number">0</span>:</span><br><span class="line">                accuracy = self.get_accuracy(data_x, data_y)</span><br><span class="line">                print(<span class="string">"Training accuracy for epoch &#123;&#125;: &#123;&#125;"</span>.format(itr, accuracy))</span><br><span class="line">                training_accuracy.append(accuracy)</span><br><span class="line">            <span class="keyword">if</span> test_x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> test_y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> itr % test_acc_rec == <span class="number">0</span>:</span><br><span class="line">                accuracy = self.get_accuracy(test_x, test_y)</span><br><span class="line">                print(<span class="string">"Testing accuracy for epoch &#123;&#125;: &#123;&#125;"</span>.format(itr, accuracy))</span><br><span class="line">                test_accuracy.append(accuracy)</span><br><span class="line">            print(<span class="string">"-----"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> training_loss, training_accuracy, test_accuracy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_fig</span><span class="params">(x, y, x_label=<span class="string">"Epoch"</span>, y_label=<span class="string">""</span>, save=False)</span>:</span></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(x, y, <span class="string">"r--"</span>, linewidth=<span class="number">1</span>)</span><br><span class="line">    plt.xlabel(x_label)</span><br><span class="line">    plt.ylabel(y_label)</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="keyword">if</span> save:</span><br><span class="line">        <span class="keyword">import</span> calendar</span><br><span class="line">        <span class="keyword">import</span> time</span><br><span class="line">        ts = calendar.timegm(time.gmtime())</span><br><span class="line">        plt.savefig(str(ts))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    nn = SimpleCNN()</span><br><span class="line">    MNIST_data = h5py.File(<span class="string">'MNISTdata.hdf5'</span>, <span class="string">'r'</span>)</span><br><span class="line">    x_train = np.array(MNIST_data[<span class="string">'x_train'</span>])</span><br><span class="line">    y_train = np.array(np.array(MNIST_data[<span class="string">'y_train'</span>][:, <span class="number">0</span>]))</span><br><span class="line">    x_test = np.array(MNIST_data[<span class="string">'x_test'</span>])</span><br><span class="line">    y_test = np.array(np.array(MNIST_data[<span class="string">'y_test'</span>][:, <span class="number">0</span>]))</span><br><span class="line">    MNIST_data.close()</span><br><span class="line"></span><br><span class="line">    LR = <span class="number">0.001</span></span><br><span class="line">    MAX_EPOCH = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    loss, train_acc, test_acc = nn.train(x_train, y_train, MAX_EPOCH, LR, test_x=x_test, test_y=y_test)</span><br><span class="line">    x = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, MAX_EPOCH + <span class="number">1</span>)]</span><br><span class="line">    plot_fig(x, loss, y_label=<span class="string">"Loss"</span>)</span><br><span class="line">    plot_fig(x, train_acc, y_label=<span class="string">"Training Accuracy"</span>)</span><br><span class="line">    plot_fig(x, test_acc, y_label=<span class="string">"Testing Accuracy"</span>)</span><br><span class="line">    print(<span class="string">"Test accuracy: &#123;&#125;"</span>.format(nn.get_accuracy(x_test, y_test)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2>训练结果</h2><p>上述代码利用3x3x3的卷积核，0.001的初始学习率，训练了10个epoch，最终得到96%的测试准确率。训练结果过程图如下：<br>Figure 1. Epoch vs Loss<br><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/blog_pic/cnn_loss.png" width="75%" height="75%"><br>Figure 2. Epoch vs Training Accuracy<br><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/blog_pic/cnn_train_acc.png" width="75%" height="75%"><br>Figure 3. Epoch vs Testing Accuracy<br><img src="https://raw.githubusercontent.com/tengdai722/tengdai722.github.io/master/img/blog_pic/cnn_test_acc.png" width="75%" height="75%"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
